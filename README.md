# Java

## Вовед во Java
### Маратон
Да се дефинира интерфејс IMaraton со методи:<br />

Atleticar najdobroVreme() - го враќа победникот на маратонот<br />

int atleticariOd(String s) - го враќа бројот на атлетичари со земја на потекло s.<br />

Да се дефинира класа Atleticar. За секој атлетичар се чуваат податоци за име String, пол String, возраст int и време на истрчување изразено во секунди double и земја на потекло String. За оваа класа треба да се на располагање следните методи:<br />

конструктори (default и со параметри)<br />

set и get методи<br />

toString() - формат: име / возраст / земја на потекло / време на истрчување (сите параметри одделени со празно место)<br />

Да се дефинира класа Maraton што го имплементира интерфејсот IMaraton. За секој маратонот се чуваат податоци за местото на одржување String, година int, низа од атлетичари Atleticar[]. За оваа класа да се имплементираат:
<br />

конструктори (default и со параметри)<br />

set и get методи<br />

toString() - место на одржување / година / атлетичарите учесници на маратонот (сите параметри одделени со нов ред)<br />

najdobroVreme()<br />

atleticariOd(String s)<br />

### Патување
Да се моделира класата Patuvanje. Во неа се чуваат информации за името на агенцијата која го организира String и цената на патувањето int. За класата да се имплементира соодветниот конструктор и set() и get() методите. За секоје патување времетраењето на истото може да се пресмета со методата со потпис: int vratiVremeVoDenovi();.<br />

Едно патување може да биде или празнично патување или годишен одмор. Да се моделираат класите PraznicnoPatuvanje и GodishenOdmor. Притоа, покрај името и цената за сакој годишен одмор се чува податок за времетраењето на патувањето во денови int, додека за секоје празнично патување се чуваат податоци за почетен датум int и месец int и краен датум int и месец int на патувањето врз база на кои може да се одреди бројот на денови (се зема дека сите месеци имаат 30 денови).<br />

За класите PraznicnoPatuvanje и GodishenOdmor да се креираат и потребните конструктори и get() методи, како и да се имплементираат потребните методи. Дополнително, да се земе предвид дека вистинската цена на годишниот одмор е за 1000 денари поефтин. Овие 1000 денари ги плаќа државта. Исклучоци: Празничните патувања се изведуваат во иста година и притоа почетниот датум треба да му претходи календарски на крајниот датум од патувањето. Ако се направи обид за креирање на објект од класата PraznicnoPatuvanje каде тоа не е исполнето, потребно е да фрлите општ исклучок Exception. Истиот треба да се фати во конструкторот каде што е фрлен и да се справите со истиот така што ќе ги замените вредностите за денот и месецот кога патувањето почнува со денот и месецот кога тоа завршува. Притоа ако исклучокот е фатен да се отпечати во нов ред порака на екранот: Iskluchok.<br />

Во main методата на класата Test креирана е низа од n променливи од типPatuvanje (nizaPatuvanje). Од стандарден влез се внесуваат информациите за елементите од низата. Ваша задача е во определеното место во методата да ги исполните следните барања:<br />

(Барање 1) На стандарден излез да ги отпечатите сите имиња на агенции кои нудат празнични патувања кои почнуваат во месец Јуни т.е. 6тиот месец од годината (во еден ред и одвоени со празно место).<br />
(Барање 2) На стандарден излез да го отпечатите просечното времетраење на сите патувања изразено во денови.<br />
(Барање 3) Од стандарден влез да ги прочитате информациите за еден годишен одмор (ime, cena, vremetraenje) . Да се креира променлива odmor од тип GodishenOdmor која референцира објект од тип (GodishenOdmor) креиран со информациите од влезот.<br />
(Барање 4) На стандарден излез отпечатете минимална цена на она патување меѓу оние патувања кои се подолги од вчитаниот годишен одмор (odmor) . Притоа за таа цел да се искористи метода со потпис int vratiMinCena(Patuvanje [] niza, int n, Patuvanje zaSporedba); Оваа метода е статичка во класата Patuvanje. Таа ја враќа минималната цена на патувањето од низата niza кое е подолго од патувањето zaSporedba . Ако нема такво патување функцијата треба да врати 0.<br />

## Низи и листи
### Средна вредност
За дадена низа од N (1≤N≤50) природни броеви, да се најде бројот кој е најблиску до нивниот просек. Ако постојат два броја со исто растојание до просекот, да се врати помалиот од нив. На пример за низата 1, 2, 3, 4, 5 просекот е (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3, што значи дека бројот кој треба да се врати и е најблиску до просекот е 3.<br />

За низата 1, 2, 3, 4, 5, 6 просекот е 3.5 и двата броја 3 и 4 се на исто растојание од просекот. Точната вредност која треба да се врати е помалиот од нив, а тоа е 3.<br />

Во низата може да има дупликати.

Првиот број од влезот е бројот на елементи во низата N, а потоа во секој ред се дадени броевите.

Име на класата (Java): Array

**Забелешка:** Да се креира податочна структура низа и истата да се искористи во задачата.<br />

### Спој листи
Дадени се две еднострано поврзани листи чии јазли содржат по еден природен број. Листите се сортирани во растечки редослед. Треба да се спојат двете листи во една така што резултантната листа да е сортирана. Сортирањето е подредување со слевање. Јазлите кои се јавуваат како дупликати (од иста листа или од различна) да се отстранат.

Во првиот ред од влезот е даден бројот на јазли во првата листа, потоа во вториот ред се дадени броевите од кои се составени јазлите по редослед во првата листа, па во третиот ред е даден бројот на јазли во втората листа, и на крај во четвртиот ред броевите од кои се составени јазлите по редослед во втората листа. На излез треба да се испечатат јазлите по редослед во резултантната споена листа.

Име на класата (Java): SLLJoinLists

Забелешка: Да се креира податочна структура еднострано поврзана листа и истата да се искористи во задачата.<br />

### Спој листи наизменично
Дадени се две еднострано поврзани листи чии што јазли содржат по еден природен број. Треба да се спојат двете листи во една резултантна на тој начин што наизменично прво ќе се додаваат првите два јазли од првата листа во резултантната, па првите два од втората листа, па следните два од првата, па следните два од втората итн. Јазлите што ќе останат треба да се додадат на крај во резултантната листа, прво оние што останале од првата листа, потоа оние што останале од втората листа.

Во првиот ред од влезот се дадени броевите од кои се составени јазлите по редослед во првата листа, а во вториот ред броевите од кои се составени јазлите по редослед во втората листа. На излез треба да се испечатат јазлите по редослед во резултантната споена листа.

Забелешка: Да се креира податочна структура еднострано поврзана листа и истата да се искористи во задачата.<br />

## Двострано поврзани листи. Техники алгоритми - основни
### Двојно поврзана листа: Раздели по парност 
Дадена е двојно поврзана листа и со N јазли кои во себе содржат по еден природен број. Треба да се подели листата на две резултантни листи. Во првата резултантна листа треба да се преместат јазлите со непарни броеви, а во втората со парните.

Во првиот ред од влезот е даден бројот на јазли во листата, а потоа во вториот ред се дадени јазлите од кои е составена. На излез треба да се испечатат во еден ред јазлите на првата листа со непарните броеви, а во втор ред јазлите на втората листа со парните броеви.

Име на класата (Java): DivideOddEven<br />

### Компанија
Податоците за плати на вработените во една компанија привремено се чуваат во двострано поврзана листа. Во секој јазол од листата се чува единствен ID на вработениот и неговата плата. Потребно е да се отстранат сите вработени со помали плати од даден износ, а остатокот да се прикажат во опаѓачки редослед во однос на ID-то.

Во првиот ред од влезот е даден бројот на вработени, потоа наизменично се дадени ID-та и платата за секој од вработените и во последниот ред е износот во однос на кој ќе се отстрануваат вработените. На излез се печати листа (ID, плата) во опаѓачки редослед според ID-то на секој од вработените.

Доколку нема вработени со плата поголема од дадената да се испечати: nema

Име на класата: DLLKompanija<br />

### Факултет
Петко е студент на факултетот Ф. Тој слуша N предмети. Еден ден, сите професори на N-те предмети истовремено му дале на Петко по една домашна работа која што треба да се изработи што е можно побрзо. За секоја од домашните работи на Петко му треба одредено време за да ја изработи. Правилото при испраќање на домашната задача е дека се добиваат од старт онолку казнени поени колку што часа поминале од објавувањето на соопштението за домашната работа. Петко истовремено може да решава само една задача. Потребно е да напишете програма која што за даден број на предмети и проценка за тоа колку часа на Петко би му требало за решавање на секоја од домашните, ќе пресмета минимален број на казнени поени што ќе ги добие при испраќање на сите задачи.

Во првиот ред од влезот даден е бројот на домашни задачи N. Во секој од следните N редови даден е бројот на часови што се потребни за решавање за секоја од домашните задачи. На излез треба да се испечати минималниот број на казнени поени.

Име на класата (Java): Homework<br />

## Техники алгоритми 
### Аритметички израз
Даден е некој аритметички израз. Аритметичкиот израз е во облик (A+B) или (A-B) каде што А и B истовремено се други аритметички изрази или цифри од 0-9. Потребно е да го евалуирате дадениот израз.

Име на класата (Java): ArithmeticExpression

### Цик цак секвенца
Секвенца од броеви се смета за цик цак секвенца ако броевите во секвенцата се наизменично позитивни и негативни т.е. за секој пар од последователни броеви важи дека едниот е позитивен, а другиот е негативен.

На пример -1 2 -9 8 -4 е цик цак секвенца, но -1 9 7 -3 8 -3 не е, затоа што 9 и 7 се соседни броеви, но и двата се позитивни. Цик цак секвенцата може да почне или со позитивен или со негативен број. Секвенца од само еден ненулти број се смета како цик цак секвенца. За дадена низа од броеви да се напише алгоритам кој ќе ја врати должината на најдолгата подниза која претставува цик цак секвенца.

Во првиот ред од влезот даден е бројот N за должината на низата. Во секој од следните N редови е даден по еден број од оригиналната низа. На излез треба да се испечати должината на најдолгата подниза која е цик цак секвенца од оригиналната низа.

Име на класата: ZigZagSequence

### Сума од апсолутни разлики (Тип колоквиумска задача)
Дадена е низа од N природни броеви и еден број K. Нека броевите се означени од a0 до aN−1. Да ја дефинираме сумата од апсолутни разлики како abs(a1−a0)+abs(a2−a1)+…+abs(aN−1−aN−2). Да се изберат точно K броеви од низата, така што кога ќе се спојат во една низа, сумата од апсолутни разлики е максимална. Да се испечати оваа сума.

Влез: Во првата линија ви се дадени два броеви N (1≤N≤100) и K (1≤K≤100, K≤N). Во втората линија ви се дадени N позитивни природни броеви, секој од броевите е помал од 1,000.

Излез: Да се испечати бараната максималната сума од апсолутни разлики.

Забелешка: Броевите се земаат во оној редослед во кој што се дадени во првата низа. Не смее да се менува редоследот на броевите во новодобиената низа.

Име на класата (Java): SumOfAbsoluteDifferences.

Делумно решение: Задачата се смета за делумно решена доколку се поминати 5 тест примери.

## Еднодимензионални податочни структури
### Постфикс нотација
Да се напише алгоритам кој ќе врши евалуација на израз во постфикс нотација.

На влез се чита низа од знаци за изразот (стринг), а на излез се печати вредноста на изразот по евалуацијата.

Име на класата (Java): PostFixEvaluation

### Модифициран XML код
Даден е некој модифициран XML код. Модифицираниот XML код ги користи симболите '[' и ']', за отварање и затворање на таг, соодветно, наместо стандардните '<' и '>'. Треба да се провери дали сите тагови во кодот се правилно вгнездени (дали кодот е валиден) т.е. дали секој отворен таг има соодветен затворен таг со истото име на соодветното место во кодот. За поедноставување, дадено е дека секој отворен таг мора да има свој затворен таг и дека таговите немаат атрибути.

На влез е даден бројот на редови во кодот и самиот XML со секој таг во посебен ред, а на излез треба да се испечати 1 или 0 за валиден или невалиден код, соодветно.

Објаснување: Во модифицираниот XML код секој отворен таг е во облик [imeNaTag], а соодветниот затворен таг е во облик [/imeNaTag].

Пример за правилно вгнездени тагови во XML e:
```
[tag1]
[tag2] 
Podatok
[/tag2] 
[/tag1] 
```
Пример за неправилно вгнездени тагови во XML e:
```
[tag1]
[tag2] 
Podatok
[/tag1]
[/tag2]
```
Име на класата (Java): CheckXML

### Шалтерот на МВР
Луѓето доаѓаат наутро во МВР за да извадат еден или повеќе документи.<br />
Документите може да бидат:<br />
1. Лична карта<br />
2. Пасош<br />
3. Возачка дозвола<br />
Кога се отвора шалтерот прво се услужуваат луѓето кои чекаат за лична карта, па потоа оние за пасош и на крај оние за возачка дозвола.<br />
Секој човек кога ќе дојде си застанува во редицата за соодветната исправа која ја вади (т.е. или во редицата за лични карти или во редицата за пасоши или во редицата за возачки дозволи). Доколку еден човек има повеќе документи за вадење прво вади лична карта, па пасош и на крај возачка. Така ако еден човек треба да вади и лична карта и возачка дозвола прво застанува во редицата за лични карти и откако ќе заврши таму оди на крајот на редицата за возачки дозволи.

Влез: Првиот ред означува колку луѓе вкупно дошле во МВР. Потоа за секој човек се внесуваат четири реда, во првиот е името и презимето на човекот, а во останатите три реда се кажува кој документ соодветно (лична карта, пасош и возачка) треба да се земе, притоа 1 значи дека треба да се земе тој документ, 0 значи дека не треба да се земе.

На пример:
```
Aleksandar Aleksandrovski
1
0
1
```
означува дека Александар Александровски ќе вади и лична карта и возачка дозвола, но нема да вади пасош.
Излез: Ги печати имињата на луѓето по редоследот по кој завршуваат со вадење на документи.

Име на класата (Java): MVR


## Сортирање 
### Непарно парно сортирање 
Дадена е низа со N природни броеви. Треба да се сортира низата така што во првиот дел од низата ќе бидат подредени непарните броеви од неа во растечки редослед, а во вториот дел парните броеви во опаѓачки редослед. Во првиот ред од влезот даден е бројот на елементи во низата N, а во вториот ред се дадени броевите. На излез треба да се испечати сортираната низа.

Име на класата: OddEvenSort

### Shaker (cocktail) сортирање
Дадена е низа со N природни броеви. Треба да се сортира низата со помош на таканареченото shaker (cocktail) сортирање. Ова сортирање е варијација на сортирањето со меурчиња (bubble sort) со тоа што во секоја итерација низата се изминува два пати. Во првото поминување најмалиот елемент се поместува на почетокот на низата, а при второто најголемиот елемент се поместува на крајот. Во првиот ред од влезот даден е бројот на елементи во низата N, а во вториот ред се дадени броевите. На излез треба да се испечати низата по секое изминување во посебен ред.

Име на класата: ShakerSort

### Сортирање со меурчиња кај листа
Дадена е една двојно поврзана листa и со N јазли кои во себе содржат по еден природен број. Треба да се сортира листата со помош на сортирањето со меурчиња (bubble sort). Во првиот ред од влезот е даден бројот на јазли во листата, а потоа во вториот ред се дадени јазлите од кои е составена. На излез треба да се испечатат јазлите на сортираната листа.

Име на класата: BubbleSortDLL

Забелешка: При реализација на задачата МОРА да се користи дадената структура, а не да користат помошни структури како низи и сл.


## Хеширање
### Лозинки
Потребно е да се симулира најава на еден систем. Притоа корисникот внесува корисничко име и лозинка. Доколку корисничкото име одговара со лозинката тогаш се печати Najaven, доколку не одговара се печати Nenajaven и на корисникот му се дава повторна шанса на корисникот да внесе корисничко име и лозинка. Во моментот кога корисникот ќе биде најавен престануваат обидите за најава.

Влез: Прво се дава број N на кориснички имиња и лозинки кои ќе бидат внесени во системот. Во наредните N реда се дадени корисничките имиња и лозинки разделени со едно празно место. Потоа се даваат редови со кориснички имиња и лозинки на корисници кои се обидувата да се најават (Пр. ana banana) За означување на крај на обидите во редицата се дава зборот KRAJ

Излез: За секој од влезовите кои се обид за најава се печати Nenajaven се додека не дoбиеме Najaven или додека имаме обиди за најава.

Пример. Влез: 3 ana banana pero zdero trpe trpi ana ana ana banana trpe trpi KRAJ

Излез: Nenajaven Najaven

Забелешка: Работете со хеш табела со затворени кофички. Самите решавате за големината на хеш табела, а хеш функцијата ви е дадена.

Име на класа: Lozinki

### Статичко рутирање
Потребно е да се симулира рутирање преку хеш табела. Секој рутер претставува една кофичка од хеш табелата и притоа пакетите на влез ги прима преку еден интерфејс. Бидејќи рутерот, рутирањето на даден пакет го врши користејќи ги статичките рути што тој ги знае, кога ќе добие пакет преку влезниот интерфејс, тој треба да даде одговор дали може да го рутира пакетот до дадениот уред во таа мрежа (postoi или nepostoi). Важно е тоа што сите адреси имаат мрежна маска /24, што значи дека последните 8 бита се наменети за адресирање. Претпоставуваме дека сите адреси се зафатени во таа мрежа, така што до било кој уред од таа мрежа, доколку ја има во рутирачката табела, може да се достави пакетот. Така што доколку во рутирачката табела има 10.10.10.0, тоа значи дека рутерот може да го проследи пакетот до сите уреди во таа мрежа (10.10.10.1- 10.10.10.254).

На влез најпрвин се внесува бројот на рутери, потоа најизменично IP адресата на влезниот интерфејс, па во следниот ред IP адресите на мрежите до кој рутерот има статички рути. Потоа се внесува бројот на обиди за рутирање на пакети. Во следните редови најизменично се внесува влезен интерфејс и IP адреса на уред за која треба да се даде одговор дали тој рутер ја познава или не. Име на класта :RoutingHashJava

### Преведувач
Треба да изработите автоматски преведувач за зборови од анлиски јазик на македонски. Влезот се состои од парови од зборови разделени со празно место. Така прво е даден зборот на македонски, па има едно празно место, па преводот на зборот на англиски јазик Потоа на влез се добиваат странски зборови (секој во посебен ред). За излез треба да се преведат овие зборови. Доколку не е познат преводот на зборот на излез се печати "/"

Влез. Прво се дава број N на поими кои ќе ги содржи речникот. Потоа во наредните N реда се дадени поимите, прв на македонски, потоа на англиски. Потоа следуваат зборови на англиски (секој збор во посебен ред), кои треба да се преведат на македонски. За означување на крај во редицата се дава зборот KRAJ

Излез. За секој од дадените зборови на англиски во посебен ред е даден преводот на зборот на македонски. Доколку не е познат преводот на зборот се печати /

Забелешка. Работете со хеш табела со отворени кофички. Сами треба да го одредите бројот на кофички и хеш функцијата.

Име на класа: Preveduvac

### Аптека
Потребно е да се направи компјутерска апликација со која ќе се забрза работењето на една аптека. Притоа апликацијата треба да му овозможи на корисникот (фармацевтот) брзо да пребарува низ огромното множество со лекови кои се внесени во системот. Начинот на кој тој треба да пребарува е следен: доволно е да ги внесе првите 3 букви од името на лекот за да може да му се излиста листа од лекови кои ги има во системот. Работата на фармацевтот е да провери дали внесениот лек го има во системот и да му даде информација на клиентот. Информацијата што треба да му ја даде на клиентот е дали лекот се наоѓа на позитивната листа на лекови, која е цената и колку парчиња од лекот има на залиха. Доколку лекот постои клиентот го нарачува со што кажува колку парчиња ќе купи. Оваа акција фармацевтот треба да ја евидентира на системот (односно да ја намали залихата на лекови за онолку парчиња колку што му издал на клиентот). Доколку нарачката на клиентот е поголема од залихата на лекот што ја има во системот, не се презема никаква акција.

Влез: Од стандарден влез прво се дава број N кој претставува број на лекови кои ќе бидат внесени во системот. Во наредните N реда се дадени имињата на лековите, дали ги има на позитивната листа (1/0), цената и број на парчиња, сите разделени со по едно празно место. Потоа се даваат редови со имиња на лекови и број на парчиња нарачани од клиентот. За означување на крај се дава зборот KRAJ.

Излез: На стандарден излез треба да се испечати за секој од влезовите следната информација: IME POZ/NEG CENA BR_LEKOVI. Доколку лекот не е најден се печати Nema takov lek. Доколку нарачката на клиентот е поголема од залихата се печати Nema dovolno lekovi инаку Napravena naracka.

Забелешка: Задачата да се реши со хeш табела. Функцијата со која се врши мапирање на имињата на лековите во број е следна: h(w)=(29∗(29∗(29∗0+ASCII(c1))+ASCII(c2))+ASCII(c3))%102780 каде зборот w=c1c2c3c4c5…. е составен од сите големи букви.

Исто така за лековите да се направи посебна класа која како атрибути ќе ги има наведените карактеристики на лекот во системот.

Име на класата: Apteka.


## Дрва
### Windows Explorer
Потребно е да имплементирате Windows Explorer со помош на дрво. Јазлите треба да ви бидат фолдери/датотеки. Почетно ќе имате само еден фолдер c: и тој ви е тековен фолдер. Ќе ви биде дадена низа од команди што можат да бидат во еден од следните типови:

CREATE [име на фолдер/датотека] - треба да креирате нов фолдер/датотека во тековниот. Треба да внимавате при додавањето, новиот фолдер/датотека треба да се смести на онаа позиција така што сите фолдери/датотеки во тековниот фолдер ќе бидат подредени лексикографски

OPEN [име на фолдер/датотека] - го отварате фолдерот во тековниот фолдер и се менува тековниот фолдер

DELETE [име на фолдер/датотека] - го бришете фолдерот/датотеката

BACK - се враќате назад во претходниот фолдер

PATH - се печати патеката на тековниот фолдер на пример: c:\users\darko\mydocuments

PRINT - се печати целата структура на датотечниот систем така што секој фолдер/датотека се печати во еден ред со онолку празни места колку што е нивото на тој фолдер/датотека

Забелешка: Имињата на фолдерите/датотеките ќе бидат составени само од еден збор што содржи мали латинични букви. Сите операции ќе бидат валидни.

Име на класата: WindowsExplorer

### Нерекурзивно изминување во preorder
Да се напише функција preorderNonRecursive за нерекурзивно изминување на бинарно стебло во preorder.

Име на класата: PreorderNonRecursive

### Збир на елементи во бинарно дрво
Дадено ви е бинарно дрво. Потоа дадена ви е вредноста на некој јазол во дрвото. Испечатете го збирот на елементите во неговото лево поддрво кои се помали од него и збирот на елементите во неговото десно поддрво кои се поголеми од него.

Име на класата (Java): BinaryTreeSum.

## Бинарни пребарувачки дрва
### Последователни броеви
Со помош на нанижано бинарно дрво потребно е да проверите дали при inorder изминување на дрвото важи дека секој следен елемент има вредност за 1 поголема од претходниот (треба да се испечати true или false). Притоа доколку ви е потребно можете да користите дополнителни функции, но не смеете да користите рекурзија и дополнителни структури.

Име на класата во Java: ConsecutiveNumbers

### Black Friday
Еден маркет за бела технка одлучил да ги спушти цените на своите производи еден работен петок дури до 80% по повод престојните Божикни празници. Поради оваа промоција јасно им било дека ќе има многу заинтересирани купувачи, па затоа одлучиле да воспостaват ред при влеувањето/излегувањето во маркетот. Купувачите влегуваат според времето на пристигнување. Потребно е да се пронајде колкав е максималниот број на купувачи кои ќе бидат присутни во маркетот. Во првата линија е даден бројот на купувачи кои чекаат да влезат, N. Секоја од наредните линии го означува часот и минутите на доаѓање на купувачот, како и колку време (во минути) ќе се задржи во маркетот, во формат: HH:MM d

За да се реализира оваа задача потребно е да се користи соодветна податочна структура со која со најмала сложеност ќе се постигне бараниот резултат. Притоа е обезбедено да не може да се случи во ист момент да има влегување односно излегување од маркетот. Маркетот работи до 23:59.

На излез треба да се испечати максималниот број купувачи кои што истовремено ќе бидат присутни во маркетот.

Име на класа во Java: BlackFriday

### Бинарно пребарувачко дрво
Да се напише рекурзивна функција за наоѓање на висината (V) на даден елемент од бинарно пребарувачко дрво (листовите имаат висина 1), а потоа да се испечати бројот на елементите кои се на длабочина V ( коренот има длабочина 0).

Најнапред се внесува бројот на темињата, па темињата, па вредноста на дадениот елемент од дрвото за кој треба да се пресмета висината. На излез се печати висината на елементот, а потоа во нов ред бројот на темиња на пресметаната длабочина.

Име на класата во Java: BinarnoDrvo
