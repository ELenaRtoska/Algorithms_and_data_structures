# Java

## Вовед во Java
### Маратон
Да се дефинира интерфејс IMaraton со методи:<br />

Atleticar najdobroVreme() - го враќа победникот на маратонот<br />

int atleticariOd(String s) - го враќа бројот на атлетичари со земја на потекло s.<br />

Да се дефинира класа Atleticar. За секој атлетичар се чуваат податоци за име String, пол String, возраст int и време на истрчување изразено во секунди double и земја на потекло String. За оваа класа треба да се на располагање следните методи:<br />

конструктори (default и со параметри)<br />

set и get методи<br />

toString() - формат: име / возраст / земја на потекло / време на истрчување (сите параметри одделени со празно место)<br />

Да се дефинира класа Maraton што го имплементира интерфејсот IMaraton. За секој маратонот се чуваат податоци за местото на одржување String, година int, низа од атлетичари Atleticar[]. За оваа класа да се имплементираат:
<br />

конструктори (default и со параметри)<br />

set и get методи<br />

toString() - место на одржување / година / атлетичарите учесници на маратонот (сите параметри одделени со нов ред)<br />

najdobroVreme()<br />

atleticariOd(String s)<br />

### Патување
Да се моделира класата Patuvanje. Во неа се чуваат информации за името на агенцијата која го организира String и цената на патувањето int. За класата да се имплементира соодветниот конструктор и set() и get() методите. За секоје патување времетраењето на истото може да се пресмета со методата со потпис: int vratiVremeVoDenovi();.<br />

Едно патување може да биде или празнично патување или годишен одмор. Да се моделираат класите PraznicnoPatuvanje и GodishenOdmor. Притоа, покрај името и цената за сакој годишен одмор се чува податок за времетраењето на патувањето во денови int, додека за секоје празнично патување се чуваат податоци за почетен датум int и месец int и краен датум int и месец int на патувањето врз база на кои може да се одреди бројот на денови (се зема дека сите месеци имаат 30 денови).<br />

За класите PraznicnoPatuvanje и GodishenOdmor да се креираат и потребните конструктори и get() методи, како и да се имплементираат потребните методи. Дополнително, да се земе предвид дека вистинската цена на годишниот одмор е за 1000 денари поефтин. Овие 1000 денари ги плаќа државта. Исклучоци: Празничните патувања се изведуваат во иста година и притоа почетниот датум треба да му претходи календарски на крајниот датум од патувањето. Ако се направи обид за креирање на објект од класата PraznicnoPatuvanje каде тоа не е исполнето, потребно е да фрлите општ исклучок Exception. Истиот треба да се фати во конструкторот каде што е фрлен и да се справите со истиот така што ќе ги замените вредностите за денот и месецот кога патувањето почнува со денот и месецот кога тоа завршува. Притоа ако исклучокот е фатен да се отпечати во нов ред порака на екранот: Iskluchok.<br />

Во main методата на класата Test креирана е низа од n променливи од типPatuvanje (nizaPatuvanje). Од стандарден влез се внесуваат информациите за елементите од низата. Ваша задача е во определеното место во методата да ги исполните следните барања:<br />

(Барање 1) На стандарден излез да ги отпечатите сите имиња на агенции кои нудат празнични патувања кои почнуваат во месец Јуни т.е. 6тиот месец од годината (во еден ред и одвоени со празно место).<br />
(Барање 2) На стандарден излез да го отпечатите просечното времетраење на сите патувања изразено во денови.<br />
(Барање 3) Од стандарден влез да ги прочитате информациите за еден годишен одмор (ime, cena, vremetraenje) . Да се креира променлива odmor од тип GodishenOdmor која референцира објект од тип (GodishenOdmor) креиран со информациите од влезот.<br />
(Барање 4) На стандарден излез отпечатете минимална цена на она патување меѓу оние патувања кои се подолги од вчитаниот годишен одмор (odmor) . Притоа за таа цел да се искористи метода со потпис int vratiMinCena(Patuvanje [] niza, int n, Patuvanje zaSporedba); Оваа метода е статичка во класата Patuvanje. Таа ја враќа минималната цена на патувањето од низата niza кое е подолго од патувањето zaSporedba . Ако нема такво патување функцијата треба да врати 0.<br />

## Низи и листи
### Средна вредност
За дадена низа од N (1≤N≤50) природни броеви, да се најде бројот кој е најблиску до нивниот просек. Ако постојат два броја со исто растојание до просекот, да се врати помалиот од нив. На пример за низата 1, 2, 3, 4, 5 просекот е (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3, што значи дека бројот кој треба да се врати и е најблиску до просекот е 3.<br />

За низата 1, 2, 3, 4, 5, 6 просекот е 3.5 и двата броја 3 и 4 се на исто растојание од просекот. Точната вредност која треба да се врати е помалиот од нив, а тоа е 3.<br />

Во низата може да има дупликати.

Првиот број од влезот е бројот на елементи во низата N, а потоа во секој ред се дадени броевите.

Име на класата (Java): Array

**Забелешка:** Да се креира податочна структура низа и истата да се искористи во задачата.<br />

### Спој листи
Дадени се две еднострано поврзани листи чии јазли содржат по еден природен број. Листите се сортирани во растечки редослед. Треба да се спојат двете листи во една така што резултантната листа да е сортирана. Сортирањето е подредување со слевање. Јазлите кои се јавуваат како дупликати (од иста листа или од различна) да се отстранат.

Во првиот ред од влезот е даден бројот на јазли во првата листа, потоа во вториот ред се дадени броевите од кои се составени јазлите по редослед во првата листа, па во третиот ред е даден бројот на јазли во втората листа, и на крај во четвртиот ред броевите од кои се составени јазлите по редослед во втората листа. На излез треба да се испечатат јазлите по редослед во резултантната споена листа.

Име на класата (Java): SLLJoinLists

Забелешка: Да се креира податочна структура еднострано поврзана листа и истата да се искористи во задачата.<br />

### Спој листи наизменично
Дадени се две еднострано поврзани листи чии што јазли содржат по еден природен број. Треба да се спојат двете листи во една резултантна на тој начин што наизменично прво ќе се додаваат првите два јазли од првата листа во резултантната, па првите два од втората листа, па следните два од првата, па следните два од втората итн. Јазлите што ќе останат треба да се додадат на крај во резултантната листа, прво оние што останале од првата листа, потоа оние што останале од втората листа.

Во првиот ред од влезот се дадени броевите од кои се составени јазлите по редослед во првата листа, а во вториот ред броевите од кои се составени јазлите по редослед во втората листа. На излез треба да се испечатат јазлите по редослед во резултантната споена листа.

Забелешка: Да се креира податочна структура еднострано поврзана листа и истата да се искористи во задачата.<br />

## Двострано поврзани листи. Техники алгоритми - основни
### Двојно поврзана листа: Раздели по парност 
Дадена е двојно поврзана листа и со N јазли кои во себе содржат по еден природен број. Треба да се подели листата на две резултантни листи. Во првата резултантна листа треба да се преместат јазлите со непарни броеви, а во втората со парните.

Во првиот ред од влезот е даден бројот на јазли во листата, а потоа во вториот ред се дадени јазлите од кои е составена. На излез треба да се испечатат во еден ред јазлите на првата листа со непарните броеви, а во втор ред јазлите на втората листа со парните броеви.

Име на класата (Java): DivideOddEven<br />

### Компанија
Податоците за плати на вработените во една компанија привремено се чуваат во двострано поврзана листа. Во секој јазол од листата се чува единствен ID на вработениот и неговата плата. Потребно е да се отстранат сите вработени со помали плати од даден износ, а остатокот да се прикажат во опаѓачки редослед во однос на ID-то.

Во првиот ред од влезот е даден бројот на вработени, потоа наизменично се дадени ID-та и платата за секој од вработените и во последниот ред е износот во однос на кој ќе се отстрануваат вработените. На излез се печати листа (ID, плата) во опаѓачки редослед според ID-то на секој од вработените.

Доколку нема вработени со плата поголема од дадената да се испечати: nema

Име на класата: DLLKompanija<br />

### Факултет
Петко е студент на факултетот Ф. Тој слуша N предмети. Еден ден, сите професори на N-те предмети истовремено му дале на Петко по една домашна работа која што треба да се изработи што е можно побрзо. За секоја од домашните работи на Петко му треба одредено време за да ја изработи. Правилото при испраќање на домашната задача е дека се добиваат од старт онолку казнени поени колку што часа поминале од објавувањето на соопштението за домашната работа. Петко истовремено може да решава само една задача. Потребно е да напишете програма која што за даден број на предмети и проценка за тоа колку часа на Петко би му требало за решавање на секоја од домашните, ќе пресмета минимален број на казнени поени што ќе ги добие при испраќање на сите задачи.

Во првиот ред од влезот даден е бројот на домашни задачи N. Во секој од следните N редови даден е бројот на часови што се потребни за решавање за секоја од домашните задачи. На излез треба да се испечати минималниот број на казнени поени.

Име на класата (Java): Homework<br />

## Техники алгоритми 
### Аритметички израз
Даден е некој аритметички израз. Аритметичкиот израз е во облик (A+B) или (A-B) каде што А и B истовремено се други аритметички изрази или цифри од 0-9. Потребно е да го евалуирате дадениот израз.

Име на класата (Java): ArithmeticExpression

### Цик цак секвенца
Секвенца од броеви се смета за цик цак секвенца ако броевите во секвенцата се наизменично позитивни и негативни т.е. за секој пар од последователни броеви важи дека едниот е позитивен, а другиот е негативен.

На пример -1 2 -9 8 -4 е цик цак секвенца, но -1 9 7 -3 8 -3 не е, затоа што 9 и 7 се соседни броеви, но и двата се позитивни. Цик цак секвенцата може да почне или со позитивен или со негативен број. Секвенца од само еден ненулти број се смета како цик цак секвенца. За дадена низа од броеви да се напише алгоритам кој ќе ја врати должината на најдолгата подниза која претставува цик цак секвенца.

Во првиот ред од влезот даден е бројот N за должината на низата. Во секој од следните N редови е даден по еден број од оригиналната низа. На излез треба да се испечати должината на најдолгата подниза која е цик цак секвенца од оригиналната низа.

Име на класата: ZigZagSequence

### Сума од апсолутни разлики (Тип колоквиумска задача)
Дадена е низа од N природни броеви и еден број K. Нека броевите се означени од a0 до aN−1. Да ја дефинираме сумата од апсолутни разлики како abs(a1−a0)+abs(a2−a1)+…+abs(aN−1−aN−2). Да се изберат точно K броеви од низата, така што кога ќе се спојат во една низа, сумата од апсолутни разлики е максимална. Да се испечати оваа сума.

Влез: Во првата линија ви се дадени два броеви N (1≤N≤100) и K (1≤K≤100, K≤N). Во втората линија ви се дадени N позитивни природни броеви, секој од броевите е помал од 1,000.

Излез: Да се испечати бараната максималната сума од апсолутни разлики.

Забелешка: Броевите се земаат во оној редослед во кој што се дадени во првата низа. Не смее да се менува редоследот на броевите во новодобиената низа.

Име на класата (Java): SumOfAbsoluteDifferences.

Делумно решение: Задачата се смета за делумно решена доколку се поминати 5 тест примери.

## Еднодимензионални податочни структури
### Постфикс нотација
Да се напише алгоритам кој ќе врши евалуација на израз во постфикс нотација.

На влез се чита низа од знаци за изразот (стринг), а на излез се печати вредноста на изразот по евалуацијата.

Име на класата (Java): PostFixEvaluation

### Модифициран XML код
Даден е некој модифициран XML код. Модифицираниот XML код ги користи симболите '[' и ']', за отварање и затворање на таг, соодветно, наместо стандардните '<' и '>'. Треба да се провери дали сите тагови во кодот се правилно вгнездени (дали кодот е валиден) т.е. дали секој отворен таг има соодветен затворен таг со истото име на соодветното место во кодот. За поедноставување, дадено е дека секој отворен таг мора да има свој затворен таг и дека таговите немаат атрибути.

На влез е даден бројот на редови во кодот и самиот XML со секој таг во посебен ред, а на излез треба да се испечати 1 или 0 за валиден или невалиден код, соодветно.

Објаснување: Во модифицираниот XML код секој отворен таг е во облик [imeNaTag], а соодветниот затворен таг е во облик [/imeNaTag].

Пример за правилно вгнездени тагови во XML e:
```
[tag1]
[tag2] 
Podatok
[/tag2] 
[/tag1] 
```
Пример за неправилно вгнездени тагови во XML e:
```
[tag1]
[tag2] 
Podatok
[/tag1]
[/tag2]
```
Име на класата (Java): CheckXML

### Шалтерот на МВР
Луѓето доаѓаат наутро во МВР за да извадат еден или повеќе документи.<br />
Документите може да бидат:<br />
1. Лична карта<br />
2. Пасош<br />
3. Возачка дозвола<br />
Кога се отвора шалтерот прво се услужуваат луѓето кои чекаат за лична карта, па потоа оние за пасош и на крај оние за возачка дозвола.<br />
Секој човек кога ќе дојде си застанува во редицата за соодветната исправа која ја вади (т.е. или во редицата за лични карти или во редицата за пасоши или во редицата за возачки дозволи). Доколку еден човек има повеќе документи за вадење прво вади лична карта, па пасош и на крај возачка. Така ако еден човек треба да вади и лична карта и возачка дозвола прво застанува во редицата за лични карти и откако ќе заврши таму оди на крајот на редицата за возачки дозволи.

Влез: Првиот ред означува колку луѓе вкупно дошле во МВР. Потоа за секој човек се внесуваат четири реда, во првиот е името и презимето на човекот, а во останатите три реда се кажува кој документ соодветно (лична карта, пасош и возачка) треба да се земе, притоа 1 значи дека треба да се земе тој документ, 0 значи дека не треба да се земе.

На пример:
```
Aleksandar Aleksandrovski
1
0
1
```
означува дека Александар Александровски ќе вади и лична карта и возачка дозвола, но нема да вади пасош.
Излез: Ги печати имињата на луѓето по редоследот по кој завршуваат со вадење на документи.

Име на класата (Java): MVR


## Сортирање 
### Непарно парно сортирање 
Дадена е низа со N природни броеви. Треба да се сортира низата така што во првиот дел од низата ќе бидат подредени непарните броеви од неа во растечки редослед, а во вториот дел парните броеви во опаѓачки редослед. Во првиот ред од влезот даден е бројот на елементи во низата N, а во вториот ред се дадени броевите. На излез треба да се испечати сортираната низа.

Име на класата: OddEvenSort

### Shaker (cocktail) сортирање
Дадена е низа со N природни броеви. Треба да се сортира низата со помош на таканареченото shaker (cocktail) сортирање. Ова сортирање е варијација на сортирањето со меурчиња (bubble sort) со тоа што во секоја итерација низата се изминува два пати. Во првото поминување најмалиот елемент се поместува на почетокот на низата, а при второто најголемиот елемент се поместува на крајот. Во првиот ред од влезот даден е бројот на елементи во низата N, а во вториот ред се дадени броевите. На излез треба да се испечати низата по секое изминување во посебен ред.

Име на класата: ShakerSort

### Сортирање со меурчиња кај листа
Дадена е една двојно поврзана листa и со N јазли кои во себе содржат по еден природен број. Треба да се сортира листата со помош на сортирањето со меурчиња (bubble sort). Во првиот ред од влезот е даден бројот на јазли во листата, а потоа во вториот ред се дадени јазлите од кои е составена. На излез треба да се испечатат јазлите на сортираната листа.

Име на класата: BubbleSortDLL

Забелешка: При реализација на задачата МОРА да се користи дадената структура, а не да користат помошни структури како низи и сл.


## Хеширање
